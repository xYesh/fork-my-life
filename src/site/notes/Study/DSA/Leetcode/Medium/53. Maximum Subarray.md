---
{"dg-publish":true,"permalink":"/study/dsa/leetcode/medium/53-maximum-subarray/","tags":["leetcode/array","leetcode/divide-and-conquer","leetcode/dynamic-programming","programming/practice"]}
---


- [ ] Maximum Subarray  [link](https://ticktick.com/webapp/#p/674f4562ebbe1a00000002b9/tasks/675075c07c6cbc102068019d) #ticktick  

## Problem Statement
Given an integer array `nums`, find the <span data-keyword="subarray-nonempty">subarray</span> with the largest sum, and return *its sum*.

 

>[!Example]+ Example 1
>**Input**: `nums = [-2,1,-3,4,-1,2,1,-5,4]`
>**Output**: `6`
>**Explanation**: `The subarray [4,-1,2,1] has the largest sum 6.
>`

>[!Example]+ Example 2
>**Input**: `nums = [1]`
>**Output**: `1`
>**Explanation**: `The subarray [1] has the largest sum 1.
>`

>[!Example]+ Example 3
>**Input**: `nums = [5,4,-1,7,8]`
>**Output**: `23`
>**Explanation**: `The subarray [5,4,-1,7,8] has the largest sum 23.
>`

>[!warning]+ Constraints
>- `1 <= nums.length <= 10^5`
>
>- `-10^4 <= nums[i] <= 10^4`
>
>
>
>
>
>
>
>
>Follow up: If you have figured out the `O(n)` solution, try coding another solution using the divide and conquer approach, which is more subtle.

## Relevant Concepts
- [[Study/DSA/Algorithms/Dynamic Programming#Kadane's Algorithm\|Dynamic Programming#Kadane's Algorithm]]

## Approach
- 
## Solution
```Java

```

## Complexity Analysis
- Time complexity: 
- Space complexity: 

## Reflections
- 